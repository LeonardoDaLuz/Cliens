{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { createSlice } from '@reduxjs/toolkit';\nimport config from '../config';\nimport { mergePathWithQueryAndQuery } from '../utils/mergePathWithQueryAndQuery';\nimport { waitForSeconds } from '../utils/waitForSeconds';\nimport { useHistory } from 'react-router';\n//Como estamos usando json server não há um padrao esquematizado de resposta.\nconst initialState = {\n  status: 'idle',\n  pointer: 0,\n  lastKey: '',\n  data: {},\n  loadCompleted: false,\n  holdInfiniteLoader: false,\n  currentPath: '',\n  currentQuery: '',\n  currentKey: '',\n  currentUrl: '',\n  currentQuantity: 30,\n  reloadTrigger: false\n};\nconst customersSlice = createSlice({\n  name: 'customers',\n  initialState,\n  reducers: {\n    reconfigureInfiniteLoader: (state, action) => {\n      state.holdInfiniteLoader = true;\n      state.loadCompleted = false;\n      state.pointer = 0;\n      state.currentQuantity = action.payload.quantity ? action.payload.quantity : state.currentQuantity;\n      state.reloadTrigger = true;\n\n      if (action.payload.path && action.payload.query !== undefined) {\n        state.currentPath = action.payload.path;\n        state.currentQuery = action.payload.query;\n        state.currentKey = mergePathWithQueryAndQuery(action.payload.path, action.payload.query);\n        state.currentUrl = config.apiUrl + mergePathWithQueryAndQuery(state.currentKey, '&_start=' + state.pointer + '&_limit=' + state.currentQuantity);\n      } else {\n        console.error('action.path or action.query not found');\n      }\n    },\n    infiniteCustomerLoaderStop: state => {\n      state.holdInfiniteLoader = false;\n    },\n    customerLoaderStart: (state, action) => {\n      state.reloadTrigger = false;\n      state.status = 'loading';\n      state.lastKey = action.payload.key;\n      state.currentUrl = config.apiUrl + mergePathWithQueryAndQuery(state.currentKey, '&_start=' + state.pointer + '&_limit=' + state.currentQuantity);\n    },\n    customerLoaderSuccess: (state, action) => {\n      state.status = 'loaded';\n      if (state.data[action.payload.key]) state.data[action.payload.key].splice(action.payload.pointer, action.payload.payload.length, ...action.payload.payload);else state.data[action.payload.key] = action.payload.payload;\n      if (state.lastKey === action.payload.key && action.payload.payload.length < action.payload.quantity) state.loadCompleted = true;else state.loadCompleted = false;\n      state.lastKey = action.payload.key;\n      state.pointer = action.payload.pointer + action.payload.payload.length;\n    },\n    clientSearchFailure: (state, action) => {\n      state.status = 'fail';\n    },\n    infiniteLoaderPointerReset: state => {\n      state.loadCompleted = false;\n      state.pointer = 0;\n    },\n    previewDeleteCustomer: (state, action) => {\n      state.data[state.currentKey].forEach((item, index) => {\n        if (item.id === action.payload.id) {\n          state.data[state.currentKey].splice(index, 1);\n        }\n      });\n    }\n  }\n});\nexport default customersSlice.reducer;\nexport const {\n  reconfigureInfiniteLoader,\n  infiniteCustomerLoaderStop,\n  infiniteLoaderPointerReset,\n  customerLoaderStart,\n  customerLoaderSuccess,\n  clientSearchFailure,\n  previewDeleteCustomer\n} = customersSlice.actions;\nexport const infiniteCustomerLoaderThunk = (path = '', query = '', quantity = 30) => {\n  return async (dispatch, getState) => {\n    dispatch({\n      type: 'customers/infiniteCustomerLoaderStart'\n    });\n    dispatch(reconfigureInfiniteLoader({\n      path,\n      query,\n      quantity\n    }));\n    await waitForSeconds(0.1);\n    let customersState = getState().customers;\n\n    while (customersState.holdInfiniteLoader) {\n      if (customersState.reloadTrigger || !customersState.loadCompleted && window.pageYOffset > document.body.clientHeight - window.innerHeight - 3000 || customersState.pointer < customersState.data[customersState.currentKey].length - customersState.currentQuantity) {\n        await loadMoreClients(dispatch, getState);\n      } else {\n        await waitForSeconds(0.1);\n      }\n\n      customersState = getState().customers;\n    }\n\n    dispatch(infiniteCustomerLoaderStop());\n  };\n};\nexport async function loadMoreClients(dispatch, getState) {\n  _s();\n\n  //   let customersState = getState().customers;\n  let {\n    customers: customersState\n  } = getState();\n  dispatch(customerLoaderStart({\n    url: customersState.currentUrl,\n    key: customersState.currentKey\n  }));\n  customersState = getState().customers;\n  const result = await fetch(customersState.currentUrl);\n  const history = useHistory();\n\n  if (result.status === 200) {\n    const data = await result.json();\n\n    if ('auth' in data) {\n      dispatch(clientSearchFailure({\n        error: data['message']\n      }));\n      await waitForSeconds(2);\n    } else {\n      dispatch(customerLoaderSuccess({\n        payload: data,\n        url: customersState.currentUrl,\n        pointer: customersState.pointer,\n        key: customersState.currentKey,\n        quantity: customersState.currentQuantity\n      }));\n    }\n  } else {\n    dispatch(clientSearchFailure({\n      error: result.status\n    }));\n    await waitForSeconds(2);\n  }\n}\n\n_s(loadMoreClients, \"9cZfZ04734qoCGIctmKX7+sX6eU=\", false, function () {\n  return [useHistory];\n});","map":{"version":3,"sources":["/home/leo/Dev/Desafio_frontend_troupe_tecnologia/src/store/customers.ts"],"names":["createSlice","config","mergePathWithQueryAndQuery","waitForSeconds","useHistory","initialState","status","pointer","lastKey","data","loadCompleted","holdInfiniteLoader","currentPath","currentQuery","currentKey","currentUrl","currentQuantity","reloadTrigger","customersSlice","name","reducers","reconfigureInfiniteLoader","state","action","payload","quantity","path","query","undefined","apiUrl","console","error","infiniteCustomerLoaderStop","customerLoaderStart","key","customerLoaderSuccess","splice","length","clientSearchFailure","infiniteLoaderPointerReset","previewDeleteCustomer","forEach","item","index","id","reducer","actions","infiniteCustomerLoaderThunk","dispatch","getState","type","customersState","customers","window","pageYOffset","document","body","clientHeight","innerHeight","loadMoreClients","url","result","fetch","history","json"],"mappings":"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","sourcesContent":["\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { Action } from 'redux';\nimport { AppDispatch, AppThunk, RootState } from '.';\nimport config from '../config';\nimport { mergePathWithQueryAndQuery } from '../utils/mergePathWithQueryAndQuery';\nimport { waitForSeconds } from '../utils/waitForSeconds';\nimport { FormularyType } from '../components/EditarCliente';\nimport { useHistory } from 'react-router';\n\nexport type ClientsState = {\n    readonly status: 'idle' | 'loading' | 'loaded' | 'fail',\n    readonly pointer: number,\n    readonly lastKey: string,\n    readonly data: { [key: string]: Client[] },\n    readonly loadCompleted: boolean,\n    readonly holdInfiniteLoader: boolean,\n    readonly currentPath: string,\n    readonly currentQuery: string,\n    readonly currentKey: string,\n    readonly currentUrl: string,\n    readonly currentQuantity: number,\n    readonly reloadTrigger: boolean;\n}\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P]\n};\n\nexport interface ClientsAction {\n    key?: string,\n    payload?: Client[],\n    pointer?: number,\n    quantity?: number,\n    url?: string,\n    error?: any,\n    path?: string,\n    query?: string,\n    id?: number\n}\n\nexport interface Client {\n    id: number,\n    nome: string,\n    cpf: string,\n    email: string,\n    endereco: {\n        cep: number,\n        rua: string,\n        numero: number,\n        cidade: string\n    }\n}\n\nexport type ClientsRequestResponse = Client[]; //Como estamos usando json server não há um padrao esquematizado de resposta.\n\nconst initialState: ClientsState = {\n    status: 'idle',\n    pointer: 0,\n    lastKey: '',\n    data: {},\n    loadCompleted: false,\n    holdInfiniteLoader: false,\n    currentPath: '',\n    currentQuery: '',\n    currentKey: '',\n    currentUrl: '',\n    currentQuantity: 30,\n    reloadTrigger: false,\n}\n\nconst customersSlice = createSlice({\n    name: 'customers',\n    initialState,\n    reducers: {\n        reconfigureInfiniteLoader: (state: Mutable<ClientsState>, action: PayloadAction<ClientsAction>) => {\n            state.holdInfiniteLoader = true;\n            state.loadCompleted = false;\n            state.pointer = 0;\n            state.currentQuantity = action.payload.quantity ? action.payload.quantity : state.currentQuantity;\n            state.reloadTrigger = true;\n            if (action.payload.path && action.payload.query !== undefined) {\n                state.currentPath = action.payload.path;\n                state.currentQuery = action.payload.query;\n                state.currentKey = mergePathWithQueryAndQuery(action.payload.path, action.payload.query);\n                state.currentUrl = config.apiUrl + mergePathWithQueryAndQuery(state.currentKey, '&_start=' + state.pointer + '&_limit=' + state.currentQuantity);\n            } else {\n                console.error('action.path or action.query not found');\n            }\n        },\n        infiniteCustomerLoaderStop: (state: Mutable<ClientsState>) => {\n            state.holdInfiniteLoader = false;\n        },\n        customerLoaderStart: (state: Mutable<ClientsState>, action: PayloadAction<ClientsAction>) => {\n            state.reloadTrigger = false;\n            state.status = 'loading';\n            state.lastKey = action.payload.key;\n            state.currentUrl = config.apiUrl + mergePathWithQueryAndQuery(state.currentKey, '&_start=' + state.pointer + '&_limit=' + state.currentQuantity);\n        },\n        customerLoaderSuccess: (state: Mutable<ClientsState>, action: PayloadAction<ClientsAction>) => {\n\n            state.status = 'loaded';\n\n            if (state.data[action.payload.key])\n                state.data[action.payload.key].splice(action.payload.pointer, action.payload.payload.length, ...action.payload.payload);\n            else\n                state.data[action.payload.key] = action.payload.payload;\n\n\n            if (state.lastKey === action.payload.key && action.payload.payload.length < action.payload.quantity)\n                state.loadCompleted = true;\n            else\n                state.loadCompleted = false;\n\n            state.lastKey = action.payload.key;\n\n            state.pointer = action.payload.pointer + action.payload.payload.length;\n        },\n        clientSearchFailure: (state: Mutable<ClientsState>, action: PayloadAction<ClientsAction>) => {\n            state.status = 'fail';\n        },\n        infiniteLoaderPointerReset: (state: Mutable<ClientsState>) => {\n            state.loadCompleted = false;\n            state.pointer = 0;\n        },\n        previewDeleteCustomer: (state: Mutable<ClientsState>, action: PayloadAction<ClientsAction>) => {\n            state.data[state.currentKey].forEach((item: Client, index: number )=> {\n                if(item.id===action.payload.id) {\n                    state.data[state.currentKey].splice(index, 1);\n                }\n            })\n        }\n    }\n})\n\nexport default customersSlice.reducer;\n\nexport const { reconfigureInfiniteLoader, infiniteCustomerLoaderStop, infiniteLoaderPointerReset, customerLoaderStart, customerLoaderSuccess, clientSearchFailure, previewDeleteCustomer } = customersSlice.actions;\n\n\nexport const infiniteCustomerLoaderThunk = (path = '', query = '', quantity = 30): AppThunk => {\n    return async (dispatch: AppDispatch, getState: () => RootState) => {\n\n        dispatch({ type: 'customers/infiniteCustomerLoaderStart' })\n\n        dispatch(reconfigureInfiniteLoader({ path, query, quantity }));\n\n        await waitForSeconds(0.1);\n\n        let customersState = getState().customers;\n\n        while (customersState.holdInfiniteLoader) {\n\n            if (customersState.reloadTrigger || (!customersState.loadCompleted && window.pageYOffset > document.body.clientHeight - window.innerHeight - 3000 || (customersState.pointer < customersState.data[customersState.currentKey].length - customersState.currentQuantity))) {\n                await loadMoreClients(dispatch, getState);\n            } else {\n                await waitForSeconds(0.1);\n            }\n            customersState = getState().customers;\n        }\n\n        dispatch(infiniteCustomerLoaderStop())\n    }\n}\n\nexport async function loadMoreClients(dispatch: AppDispatch, getState: () => RootState) {\n\n //   let customersState = getState().customers;\n    let { customers: customersState } = getState();\n\n    dispatch(customerLoaderStart({\n        url: customersState.currentUrl,\n        key: customersState.currentKey\n    }));\n\n    customersState = getState().customers;\n\n    const result = await fetch(customersState.currentUrl);\n\n    const history = useHistory();\n\n    if (result.status === 200) {\n\n        const data = await result.json();\n\n        if ('auth' in data) {\n               \n            dispatch(clientSearchFailure({ error: data['message'] }));\n            await waitForSeconds(2)\n        } else {\n            dispatch(customerLoaderSuccess({\n                payload: data,\n                url: customersState.currentUrl,\n                pointer: customersState.pointer,\n                key: customersState.currentKey,\n                quantity: customersState.currentQuantity\n            }))\n        }\n\n    } else {\n        dispatch(clientSearchFailure({ error: result.status }));\n        await waitForSeconds(2)\n    }        \n}\n\n\n"]},"metadata":{},"sourceType":"module"}