{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nimport config from '../config';\nimport { previewDeleteCustomer } from './customers';\n//Como estamos usando json server não há um padrao esquematizado de resposta.\nconst initialState = {\n  status: 'idle',\n  customer: null,\n  id: -1\n};\nconst customersSlice = createSlice({\n  name: 'customers',\n  initialState,\n  reducers: {\n    loadCustomerStart: (state, action) => {\n      state.status = 'loading';\n      state.id = action.payload.id;\n    },\n    loadCustomerSucess: (state, action) => {\n      state.status = 'loaded';\n      state.id = action.payload.id;\n      state.customer = action.payload.customer;\n    },\n    loadCustomerFailure: (state, action) => {\n      state.status = 'loading_failed';\n      state.id = action.payload.id;\n    },\n    updateCustomerStart: (state, action) => {\n      state.status = 'updating';\n      state.id = action.payload.id;\n    },\n    updateCustomerSuccess: (state, action) => {\n      state.status = 'updated';\n      state.id = action.payload.id;\n      state.customer = action.payload.customer;\n    },\n    updateCustomerFailure: (state, action) => {\n      state.status = 'update_failed';\n      state.id = action.payload.id;\n    },\n    deleteCustomerStart: (state, action) => {\n      state.status = \"deleting\";\n      state.id = action.payload.id;\n    },\n    deleteCustomerSuccess: (state, action) => {\n      state.status = \"deleted\";\n      state.id = action.payload.id;\n    },\n    deleteCustomerFailure: (state, action) => {\n      state.status = \"deleting_failed\";\n      state.id = action.payload.id;\n    }\n  }\n});\nexport default customersSlice.reducer;\nexport const {\n  loadCustomerStart,\n  loadCustomerSucess,\n  loadCustomerFailure,\n  updateCustomerStart,\n  updateCustomerSuccess,\n  updateCustomerFailure,\n  deleteCustomerStart,\n  deleteCustomerSuccess,\n  deleteCustomerFailure\n} = customersSlice.actions;\nexport function loadCustomer(id) {\n  return async (dispatch, getState) => {\n    const url = config.apiUrl + '/clientes/' + id;\n    const rootState = getState();\n    const user = rootState.user;\n    dispatch(loadCustomerStart({\n      id,\n      url\n    }));\n    const response = await fetch(url, {\n      method: 'get',\n      headers: {\n        'x-access-token': user.token\n      }\n    });\n\n    if (response.status === 200) {\n      try {\n        const data = await response.json();\n\n        if (data.id) {\n          dispatch(loadCustomerSucess({\n            id,\n            customer: data,\n            url\n          }));\n        } else {\n          dispatch(loadCustomerFailure({\n            id,\n            error: 'strange answer ',\n            url\n          }));\n        }\n      } catch (e) {\n        dispatch(loadCustomerFailure({\n          id,\n          error: \"Failed to parse answer :\" + e,\n          url\n        }));\n      }\n    } else {\n      dispatch(loadCustomerFailure({\n        id,\n        error: response.status,\n        url\n      }));\n    }\n  };\n}\nexport function updateCustomer(id, values) {\n  return async (dispatch, getState) => {\n    const rootState = getState();\n    const user = rootState.user;\n    dispatch(updateCustomerStart({\n      id\n    }));\n    const url = config.apiUrl + '/clientes/' + (id !== -1 ? id : '');\n    const body = {\n      nome: values.name,\n      cpf: values.cpf,\n      email: values.email,\n      endereco: {\n        cep: values.cep,\n        rua: values.street,\n        numero: values.number,\n        cidade: values.city,\n        bairro: values.district\n      }\n    };\n    const response = await fetch(url, {\n      method: id === -1 ? 'POST' : 'PUT',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': config.appUrl,\n        'x-access-token': user.token\n      },\n      body: JSON.stringify(body)\n    });\n\n    if (response.status === 200 || response.status === 201) {\n      try {\n        const data = await response.json();\n\n        if (data.id) {\n          dispatch(updateCustomerSuccess({\n            id,\n            customer: data,\n            url\n          }));\n        } else {\n          dispatch(updateCustomerFailure({\n            id,\n            error: 'Invalid response, has not been updated ',\n            url\n          }));\n        }\n      } catch (e) {\n        dispatch(updateCustomerFailure({\n          id,\n          error: \"Failed to parse answer :\" + e,\n          url\n        }));\n      }\n    } else {\n      dispatch(updateCustomerFailure({\n        id,\n        error: response.status,\n        url\n      }));\n    }\n  };\n}\nexport function deleteCustomerThunk(id) {\n  return async (dispatch, getState) => {\n    dispatch(deleteCustomerStart({\n      id\n    }));\n    dispatch(previewDeleteCustomer({\n      id\n    }));\n    const url = config.apiUrl + '/clientes/' + id;\n    const response = await fetch(url, {\n      method: 'DELETE',\n      headers: {\n        'Access-Control-Allow-Origin': config.appUrl\n      }\n    });\n\n    if (response.status === 200) {\n      try {\n        const responseText = await response.text();\n\n        if (responseText == \"{}\") {\n          //Se o json server responder {} é porque foi deletado o arquivo.\n          dispatch(deleteCustomerSuccess({\n            id,\n            url\n          }));\n        } else {\n          dispatch(deleteCustomerFailure({\n            id,\n            error: 'Invalid response, has not been deleted ',\n            url\n          }));\n        }\n      } catch (e) {\n        dispatch(deleteCustomerFailure({\n          id,\n          error: \"Failed to parse answer :\" + e,\n          url\n        }));\n      }\n    } else {\n      dispatch(deleteCustomerFailure({\n        id,\n        error: response.status,\n        url\n      }));\n    }\n  };\n}","map":{"version":3,"sources":["/home/leo/Dev/Desafio_frontend_troupe_tecnologia/src/store/customer.ts"],"names":["createSlice","config","previewDeleteCustomer","initialState","status","customer","id","customersSlice","name","reducers","loadCustomerStart","state","action","payload","loadCustomerSucess","loadCustomerFailure","updateCustomerStart","updateCustomerSuccess","updateCustomerFailure","deleteCustomerStart","deleteCustomerSuccess","deleteCustomerFailure","reducer","actions","loadCustomer","dispatch","getState","url","apiUrl","rootState","user","response","fetch","method","headers","token","data","json","error","e","updateCustomer","values","body","nome","cpf","email","endereco","cep","rua","street","numero","number","cidade","city","bairro","district","appUrl","JSON","stringify","deleteCustomerThunk","responseText","text"],"mappings":"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","sourcesContent":["\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { AppDispatch, AppThunk, RootState } from '.';\nimport config from '../config';\nimport { waitForSeconds } from '../utils/waitForSeconds';\nimport { FormularyType } from '../components/EditarCliente';\nimport { previewDeleteCustomer } from './customers';\n\nexport type CustomerState = {\n    readonly status: 'idle' | 'loading' | 'loaded' | 'loading_failed' | 'updating' | 'updated' | 'update_failed' | 'deleting' | 'deleted' | 'deleting_failed',\n    readonly customer?: Customer,\n    readonly id: number\n    readonly error?: string,\n    readonly url?: string,\n\n}\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P]\n};\n\nexport interface CustomerAction {\n    id?: number,\n    error?: string,\n    customer?: Customer,\n    url?: string\n}\n\nexport interface Customer {\n    id: number,\n    nome: string,\n    cpf: string,\n    email: string,\n    endereco: {\n        cep: number,\n        rua: string,\n        numero: number,\n        cidade: string,\n        bairro: string\n    }\n}\n\nexport type ClientsRequestResponse = Customer[]; //Como estamos usando json server não há um padrao esquematizado de resposta.\n\nconst initialState: CustomerState = {\n    status: 'idle',\n    customer: null,\n    id: -1\n}\n\nconst customersSlice = createSlice({\n    name: 'customers',\n    initialState,\n    reducers: {\n        loadCustomerStart: (state: Mutable<CustomerState>, action: PayloadAction<CustomerAction>) => {\n            state.status = 'loading';\n            state.id = action.payload.id;\n        },\n        loadCustomerSucess: (state: Mutable<CustomerState>, action: PayloadAction<CustomerAction>) => {\n            state.status = 'loaded';\n            state.id = action.payload.id;\n            state.customer = action.payload.customer;\n        },\n        loadCustomerFailure: (state: Mutable<CustomerState>, action: PayloadAction<CustomerAction>) => {\n            state.status = 'loading_failed';\n            state.id = action.payload.id;\n\n        },\n        updateCustomerStart: (state: Mutable<CustomerState>, action: PayloadAction<CustomerAction>) => {\n            state.status = 'updating';\n            state.id = action.payload.id;\n        },\n        updateCustomerSuccess: (state: Mutable<CustomerState>, action: PayloadAction<CustomerAction>) => {\n            state.status = 'updated';\n            state.id = action.payload.id;\n            state.customer = action.payload.customer;\n        },\n        updateCustomerFailure: (state: Mutable<CustomerState>, action: PayloadAction<CustomerAction>) => {\n            state.status = 'update_failed';\n            state.id = action.payload.id;\n        },\n        deleteCustomerStart: (state: Mutable<CustomerState>, action: PayloadAction<CustomerAction>) => {\n            state.status = \"deleting\";\n            state.id = action.payload.id;\n        },\n        deleteCustomerSuccess: (state: Mutable<CustomerState>, action: PayloadAction<CustomerAction>) => {\n            state.status = \"deleted\";\n            state.id = action.payload.id;\n        },\n        deleteCustomerFailure: (state: Mutable<CustomerState>, action: PayloadAction<CustomerAction>) => {\n            state.status = \"deleting_failed\";\n            state.id = action.payload.id;\n        }\n\n    }\n})\n\nexport default customersSlice.reducer;\n\nexport const {\n    loadCustomerStart,\n    loadCustomerSucess,\n    loadCustomerFailure,\n    updateCustomerStart,\n    updateCustomerSuccess,\n    updateCustomerFailure,\n    deleteCustomerStart,\n    deleteCustomerSuccess,\n    deleteCustomerFailure\n} = customersSlice.actions;\n\nexport function loadCustomer(id: string): AppThunk {\n    return async (dispatch: AppDispatch, getState: () => RootState) => {\n\n        const url = config.apiUrl + '/clientes/' + id;\n\n        const rootState = getState();\n        const user = rootState.user;\n\n        dispatch(loadCustomerStart({ id, url }));\n\n        const response = await fetch(url, {\n            method: 'get',\n            headers: {\n                'x-access-token': user.token,\n            }\n        });\n\n        if (response.status === 200) {\n            try {\n                const data = await response.json();\n\n                if (data.id) {\n                    dispatch(loadCustomerSucess({ id, customer: data, url }));\n\n                } else {\n                    dispatch(loadCustomerFailure({ id, error: 'strange answer ', url }));\n                }\n\n            } catch (e) {\n                dispatch(loadCustomerFailure({ id, error: \"Failed to parse answer :\" + e, url }));\n            }\n        } else {\n            dispatch(loadCustomerFailure({ id, error: response.status, url }))\n        }\n    }\n}\n\nexport function updateCustomer(id: number, values: FormularyType): AppThunk {\n    return async (dispatch: AppDispatch, getState: () => RootState) => {\n\n        const rootState = getState();\n        const user = rootState.user;\n        \n        dispatch(updateCustomerStart({ id }));\n\n        const url = config.apiUrl + '/clientes/' + (id !== -1 ? id : '');\n\n        const body = {\n            nome: values.name,\n            cpf: values.cpf,\n            email: values.email,\n            endereco: {\n                cep: values.cep,\n                rua: values.street,\n                numero: values.number,\n                cidade: values.city,\n                bairro: values.district\n            },\n        }\n\n\n        const response = await fetch(url, {\n            method: id === -1 ? 'POST' : 'PUT',\n            headers: {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json',\n                'Access-Control-Allow-Origin': config.appUrl,\n                'x-access-token': user.token,\n\n            },\n            body: JSON.stringify(body)\n        });\n\n        if (response.status === 200 || response.status === 201) {\n            try {\n                const data = await response.json();\n\n                if (data.id) {\n                    dispatch(updateCustomerSuccess({ id, customer: data, url }));\n\n                } else {\n                    dispatch(updateCustomerFailure({ id, error: 'Invalid response, has not been updated ', url }));\n                }\n\n            } catch (e) {\n                dispatch(updateCustomerFailure({ id, error: \"Failed to parse answer :\" + e, url }));\n            }\n        } else {\n            dispatch(updateCustomerFailure({ id, error: response.status, url }))\n        }\n    }\n}\n\nexport function deleteCustomerThunk(id: number): AppThunk {\n    return async (dispatch: AppDispatch, getState: () => RootState) => {\n\n        dispatch(deleteCustomerStart({ id }));\n        dispatch(previewDeleteCustomer({ id }));\n\n        const url = config.apiUrl + '/clientes/' + id;\n\n        const response = await fetch(url, {\n            method: 'DELETE',\n            headers: {\n                'Access-Control-Allow-Origin': config.appUrl,\n            },\n        });\n\n        if (response.status === 200) {\n            try {\n                const responseText = await response.text();\n\n                if (responseText == \"{}\") { //Se o json server responder {} é porque foi deletado o arquivo.\n                    dispatch(deleteCustomerSuccess({ id, url }));\n                } else {\n                    dispatch(deleteCustomerFailure({ id, error: 'Invalid response, has not been deleted ', url }));\n                }\n\n            } catch (e) {\n                dispatch(deleteCustomerFailure({ id, error: \"Failed to parse answer :\" + e, url }));\n            }\n        } else {\n            dispatch(deleteCustomerFailure({ id, error: response.status, url }))\n        }\n    }\n}"]},"metadata":{},"sourceType":"module"}